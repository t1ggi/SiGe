	MODULE MDRAMAN_SPECTRES

	USE MDCONSTS
	USE MDTYPES
	USE MDBOUNDS
	USE MDSTRUCT

	PRIVATE::UVECT
	PRIVATE::COUNT_MATR
	PRIVATE::CORDRL	
      PRIVATE::COUNT_RAMAN
	PUBLIC::GET_SPECTRES

	TYPE T_SALPHA

	PRIVATE

	REAL XY
	REAL XZ
	REAL YZ

	END TYPE

	TYPE(T_COORD),PRIVATE::CRD

	CONTAINS

	!--------------------------------------------------------------
	TYPE(T_SALPHA) FUNCTION UVECT(IN,V,CRD1) 
	
	INTEGER*4 IN(4)
	TYPE(T_COORD) V
	TYPE(T_COORD) CRD1(4)

	TYPE(T_COORD) PA(4)
	TYPE(T_SALPHA) SS
	REAL*8 B1


	DO I=1,4

	IF(IN(I).EQ.0) THEN

	PA(I)%X=0.0
	PA(I)%Y=0.0
	PA(I)%Z=0.0

	ELSE

	B1=(GETR(CRD,CRD1(I)))**2 
	!(CRD%X-CRD1(I)%X)**2+(CRD%Y-CRD1(I)%Y)**2+(CRD%Z-CRD1(I)%Z)**2
	B1=SQRT(B1)
      PA(I)%X=(CRD%X-CRD1(I)%X)/B1
	PA(I)%Y=(CRD%Y-CRD1(I)%Y)/B1
	PA(I)%Z=(CRD%Z-CRD1(I)%Z)/B1	

	END IF

	END DO

	SS = T_SALPHA(0.0,0.0,0.0)

	DO I=1,4

	SS%XY=SS%XY+DBLE(PA(I)%X*PA(I)%Y)*
	*(V%X*DBLE(PA(I)%X)+V%Y*DBLE(PA(I)%Y)+V%Z*DBLE(3.d0*PA(I)%Z))
	*+V%X*DBLE(PA(I)%Y*2.D0*PA(I)%Z**2)

	SS%XZ=SS%XZ+DBLE(PA(I)%X*PA(I)%Z)*
	*(V%X*DBLE(PA(I)%X)+V%Y*DBLE(3.d0*PA(I)%Y)+V%Z*DBLE(PA(I)%Z))
	*+V%X*DBLE(PA(I)%Z*2.D0*PA(I)%Y**2)

   2	SS%YZ=SS%YZ+DBLE(PA(I)%Y*PA(I)%Z)*
	*(V%X*DBLE(3.d0*PA(I)%X)+V%Y*DBLE(PA(I)%Y)+V%Z*DBLE(PA(I)%Z))
     *+V%Y*DBLE(PA(I)%Z*2.D0*PA(I)%X**2)

	END DO

	UVECT = SS

	END FUNCTION
	!-----------------------------------------------------------------
	SUBROUTINE COUNT_MATR(CRD2,CRD2A,NNN,NNNR)

	INTEGER*4 NNN(4,4)
	INTEGER*4,INTENT(INOUT)::NNNR(4,3)
	TYPE(T_COORD),INTENT(IN):: CRD2A(4,4)
	TYPE(T_COORD),INTENT(INOUT)::CRD2(4,3)

	REAL CRDT

	DO N1=1,4

	N2=0
	KRITER=0

	DO K=1,3

	N2=N2+1
	
      IF(N2.LE.4) THEN
	
      CRDT=(GETR(CRD2A(N1,N2),CRD))**2 
	!(CRD2A(N1,N2)%X-CRD%X)**2+(CRD2A(N1,N2)%Y-CRD%Y)**2+(CRD2A(N1,N2)%Z-CRD%Z)**2
	

      IF(CRDT.GE.3.0*1E-6) THEN
	
	CRD2(N1,K) = CRD2A(N1,N2)
	NNNR(N1,K) = NNN(N1,N2)
	 
      END IF
      
	END IF

	END DO

	END DO
	
      END SUBROUTINE 
	!-----------------------------------------------------------------
	TYPE(T_COORD) FUNCTION CORDRL(STRUCT,J,CRD1,CRD2A,CRD3,NN,NNN)

	TYPE(T_STRUCT) STRUCT
	INTEGER J
	TYPE(T_COORD),INTENT(INOUT)::CRD1(4),CRD2A(4,4),CRD3(4,4,4)
	INTEGER,INTENT(INOUT)::NN(4),NNN(4,4)

	INTEGER PP,QQ

	L=1
	M=1

	DO1:DO PP=1,4

	NB1 =  STRUCT%ATS(J)%NEIBR(PP)
!	CRD1(PP)=COORD(A(NB1)%X,A(NB1)%Y,A(NB1)%Z)
	CRD1(PP)%X=STRUCT%ATS(NB1)%X
	CRD1(PP)%Y=STRUCT%ATS(NB1)%Y
	CRD1(PP)%Z=STRUCT%ATS(NB1)%Z

	NN(PP) = NB1
	
     	IF1:IF(NGLUB.EQ.1) THEN

	L=2

	ELSE

	L=3

	DO2:DO QQ=1,4

	NB2 = STRUCT%ATS(NB1)%NEIBR(QQ)
	CRD2A(PP,QQ)=T_COORD(STRUCT%ATS(NB2)%X,STRUCT%ATS(NB2)%Y,
	1STRUCT%ATS(NB2)%Z)
	NNN(PP,QQ) = NB2

	IF2:IF(NGLUB.EQ.2) THEN

	M=2

	ELSE

	M=3

	DO3: DO N=1,4

	NB3 = STRUCT%ATS(NB2)%NEIBR(N)
	CRD3(PP,QQ,N) = T_COORD(STRUCT%ATS(NB3)%X,STRUCT%ATS(NB3)%Y,
	1STRUCT%ATS(NB3)%Z)

	END DO DO3

	END IF IF2

	END DO	DO2

	END IF IF1
      
	END DO	DO1

	CORDRL = T_COORD(STRUCT%ATS(J)%X,STRUCT%ATS(J)%Y,STRUCT%ATS(J)%Z)

	END FUNCTION
	!-------------------------------------------------------------------------------

	SUBROUTINE COUNT_RAMAN(STRUCT,DIN_MATR,EIG_VALS,ALPH)

	TYPE(T_STRUCT) STRUCT 
	REAL*8,POINTER,DIMENSION(:,:)::DIN_MATR
	REAL*8,POINTER,DIMENSION(:)::EIG_VALS
	
	!–¿Ã¿ÕŒ¬— Œ≈ –¿—œ–≈ƒ≈À≈Õ»≈
	REAL*8,POINTER,DIMENSION(:)::ALPH

	TYPE(T_COORD) CRD2(4,3),CRD1(4),CRD2A(4,4),CRD3(4,4,4)
	INTEGER NN(4),NNN(4,4),NNNR(4,3)
	TYPE(T_SALPHA) SALPH,SS
	INTEGER IN(4)
	TYPE(T_COORD) V
	

	ALLOCATE(ALPH(SIZE(EIG_VALS)))


	DO1:DO II=1,SIZE(EIG_VALS)

	IF1:IF(EIG_VALS(II).LE.0.0.OR.ABS(EIG_VALS(II)).LT.1E-3) THEN

	ALPH(II)=0.0

	ELSE

	SALPH = T_SALPHA(0.0,0.0,0.0)

	DO2: DO JJ=1,SIZE(EIG_VALS)/3

	INK = STRUCT%NUMS(JJ)%INN
	IN=(/STRUCT%ATS(INK)%NEIBR(1),STRUCT%ATS(INK)%NEIBR(2),
	1STRUCT%ATS(INK)%NEIBR(3),STRUCT%ATS(INK)%NEIBR(4)/)
	

	JZ=3*JJ
	JY=3*JJ-1
	JX=3*JJ-2

	V=T_COORD(DIN_MATR(JX,II),DIN_MATR(JY,II),DIN_MATR(JZ,II))
	
	DO3:DO K=1,4
	IF(IN(K).EQ.0.OR.IN(K).GT.STRUCT%NATOMS) IN(K)=0
      END DO DO3 
      
	CRD = CORDRL(STRUCT,INK,CRD1,CRD2A,CRD3,NN,NNN)

	CALL COUNT_MATR(CRD2,CRD2A,NNN,NNNR)

	SS = UVECT(IN,V,CRD1)  
	
      SALPH=T_SALPHA(SALPH%XY+SS%XY,SALPH%XZ+SS%XZ,SALPH%YZ+SS%YZ) 	

	END DO DO2
	

	SYMMA=SALPH%XY**2+SALPH%XZ**2+SALPH%YZ**2
	CONST=2.0
	ZNAM=1.D0/EIG_VALS(II)

	ALPH(II)=CONST*SYMMA*ZNAM

	END IF IF1

	END DO	DO1
	 
      END  SUBROUTINE

	!--------------------------------------------------------------------------------------------------------------------------
	SUBROUTINE GET_SPECTRES(STRUCT,DIN_MATR,EIG_VALS,N,DW,PHN_SP,
	1RMN_SP,ALPH,FCN_PHONON,FCN_RAMAN)

	TYPE(T_STRUCT) STRUCT
	REAL*8,POINTER,DIMENSION(:,:)::DIN_MATR	 
	REAL*8,POINTER,DIMENSION(:)::EIG_VALS	 
	TYPE(T_SPECTRE),INTENT(INOUT)::PHN_SP,RMN_SP
	REAL*8,POINTER,DIMENSION(:)::ALPH
	INTEGER*2 FCN_PHONON,FCN_RAMAN


	INTEGER*4 N
	REAL*8 DW

	REAL*8 W,W0,W2
	INTEGER*4 K
	REAL*8 SALF
	REAL*8 SUM1,SUM2

	ALLOCATE(RMN_SP%W(N))
	ALLOCATE(PHN_SP%W(N))
	ALLOCATE(RMN_SP%SP(N))
	ALLOCATE(PHN_SP%SP(N))
	ALLOCATE(RMN_SP%SPR(N))
	ALLOCATE(PHN_SP%SPR(N))

	W0=0.0

	CALL COUNT_RAMAN(STRUCT,DIN_MATR,EIG_VALS,ALPH)
	 
	DO J=1,N

	W=DFLOAT(J)*DW

	IF(J.NE.1) W0=W-DW

	W2=W0+DW*0.5

	SALF=0.0
	K=0
	SUM1=0.0
	SUM2=0.0

	DOI:DO I=1,3*STRUCT%NATOMS
	
      IF(EIG_VALS(I).LT.W.AND.EIG_VALS(I).GT.W0) THEN
      
	SALF=SALF+ALPH(I)
	K=K+1
		
      END IF 
	
      IF(FCN_PHONON.EQ.LRN)
	1SUM2=SUM2+GAM_TO*2/PI/((W2-EIG_VALS(I))**2+GAM_TO**2)	
		
	IF(FCN_RAMAN.EQ.LRN) 
     1SUM1=SUM1+ALPH(I)*GAM_TO/((W2-EIG_VALS(I))**2+GAM_TO**2)
	   
	IF(FCN_PHONON.EQ.GSN)	
	1SUM2=SUM2+2.0/PI*EXP(-(W2-EIG_VALS(I))**2/GAM_TO**2)
      
	IF(FCN_RAMAN.EQ.GSN) 
	1SUM1=SUM1+ALPH(I)*EXP(-(W2-EIG_VALS(I))**2/GAM_TO**2)
	! 
     
      END DO DOI

	PHN_SP%W(J)=(W0+W)*0.5
	PHN_SP%SP(J)=DBLE(K)/DBLE(3*STRUCT%NATOMS)
	PHN_SP%SPR(J)=SUM2/(3*STRUCT%NATOMS)

	RMN_SP%W(J)=(W0+W)*0.5*W0_SI 
	RMN_SP%SP(J)=SUM1/(3*STRUCT%NATOMS)
	RMN_SP%SPR(J)=SALF/(3*STRUCT%NATOMS)

	END DO


	END SUBROUTINE



	END MODULE